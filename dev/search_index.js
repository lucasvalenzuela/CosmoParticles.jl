var documenterSearchIndex = {"docs":
[{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"particlecollection/#Particle-Collections","page":"Particle Collections","title":"Particle Collections","text":"","category":"section"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"A set of different particles are represented by subtypes of AbstractParticleCollection. These can have a cosmological redshift attributed to them. In the context of cosmological simulations, this applies to collections of DM, gas, and star particles.","category":"page"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"For an example implementation of a concrete subtype of AbstractParticleCollection, see the source codes of ParticleCollection or RedshiftParticleCollection.","category":"page"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"AbstractParticleCollection\nParticleCollection\nParticleCollection(::Type{<:AbstractParticles})\nParticleCollection(pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles}\nParticleCollection(p::Particles, ps::Particles...)\nRedshiftParticleCollection\nRedshiftParticleCollection(::Type{<:AbstractParticles}, z::Real)\nRedshiftParticleCollection(z::T, pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles,T<:Real}\nRedshiftParticleCollection(z::Real, p::Particles, ps::Particles...)\nredshift\nCosmoParticles.get_particles\nCosmoParticles.show_properties(io::IO, mime::AbstractString, pc::AbstractParticleCollection)","category":"page"},{"location":"particlecollection/#CosmoParticles.AbstractParticleCollection","page":"Particle Collections","title":"CosmoParticles.AbstractParticleCollection","text":"abstract type AbstractParticleCollection{AP} end\n\nAbstract supertype for storing data of multiple particle types.\n\nThe particles are expected to be stored in a Dict{Symbol,<:AbstractParticles}.\n\nThe inbuilt functionality of AbstractParticleCollection includes accessing and setting properties via the following syntax:\n\nP<:AbstractParticles\npc::<:AbstractParticleCollection{P}\np::<:P\npc.dm = p\npc[:dm] === p\n\nIn addition, the following syntax is equivalent to creating an AllParticles object: pc.all. The syntax pc[:all] is not valid, however.\n\nIf the struct has additional fields, these can also be accessed by pc.field, but not by pc[:field]. The latter syntax can only be used to access the particles.\n\nMethods\n\nThe methods Base.keys, Base.values, Base.haskey, Base.empty, Base.empty!, Base.isempty, and Base.copy! are forwarded to the particle Dict.\n\nConcrete types of AbstractParticleCollection should have the following methods implemented (also see the implementation of ParticleCollection):\n\nBase.copy: returns new object containing a copy of the Dict\nBase.empty: returns an identical object, but with an empty Dict\nBase.:(==)\nredshift: implement this if the redshift of the particle collection is non-zero\nBase.propertynames: implement this if there are additional struct fields\nBase.show(io, mime, pc)\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.ParticleCollection","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"struct ParticleCollection{AP<:AbstractParticles} <: AbstractParticleCollection{AP}\n    particles::Dict{Symbol,AP}\nend\n\nBasic particle collection at redshift 0.\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.ParticleCollection-Tuple{Type{<:AbstractParticles}}","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"ParticleCollection(::Type{AP}=Particles) where {AP<:AbstractParticles}\n\nCreate an empty particle collection of the passed type.\n\nBy default, the particle collection is created for the [Particles] type.\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.ParticleCollection-Union{Tuple{Vararg{Pair{Symbol, AP}}}, Tuple{AP}} where AP<:AbstractParticles","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"ParticleCollection(pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles}\n\nCreate a particle collection from pairs of Symbols and particles.\n\nExample\n\nParticleCollection(:dm => Particles(:dm), :gas => Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.ParticleCollection-Tuple{Particles, Vararg{Particles}}","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"ParticleCollection(p::Particles...)\n\nCreate a particle collection from multiple Particles.\n\nThe Dict keys are taken from the Particles type.\n\nExample\n\nParticleCollection(Particles(:dm), Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"struct RedshiftParticleCollection{AP<:AbstractParticles,T<:Real} <: AbstractParticleCollection{AP}\n    z::T\n    particles::Dict{Symbol,AP}\nend\n\nParticle collection at a given redshift.\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection-Tuple{Type{<:AbstractParticles}, Real}","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"RedshiftParticleCollection([::Type{AP}=Particles,] z::T) where {AP<:AbstractParticles,T<:Real}\n\nCreate an empty particle collection of the passed type at redshift z.\n\nBy default, the particle collection is created for the [Particles] type.\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection-Union{Tuple{T}, Tuple{AP}, Tuple{T, Vararg{Pair{Symbol, AP}}}} where {AP<:AbstractParticles, T<:Real}","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"RedshiftParticleCollection(z::T, pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles,T<:Real}\n\nCreate a particle collection at redshift z from pairs of Symbols and particles.\n\nExample\n\nRedshiftParticleCollection(0.5, :dm => Particles(:dm), :gas => Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection-Tuple{Real, Particles, Vararg{Particles}}","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"RedshiftParticleCollection(z::Real, p::Particles...)\n\nCreate a particle collection at redshift z from multiple Particles.\n\nThe Dict keys are taken from the Particles type.\n\nExample\n\nRedshiftParticleCollection(0.5, Particles(:dm), Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.redshift","page":"Particle Collections","title":"CosmoParticles.redshift","text":"redshift(pc::AbstractParticleCollection) = 0\n\nReturns the redshift at which the particles are located.\n\nBy default, 0 is returned. This method should be overridden for concrete types of AbstractParticleCollection for which the redshift differs.\n\n\n\n\n\n","category":"function"},{"location":"particlecollection/#CosmoParticles.get_particles","page":"Particle Collections","title":"CosmoParticles.get_particles","text":"get_particles(pc::AbstractParticleCollection)\n\nReturn the particles Dict belonging to the particle collection.\n\nThis returns pc.particles by default if not overridden.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particlecollection/#CosmoParticles.show_properties-Tuple{IO, AbstractString, AbstractParticleCollection}","page":"Particle Collections","title":"CosmoParticles.show_properties","text":"CosmoParticles.show_properties(io::IO, mime, p::AbstractParticleCollection)\n\nPrints the properties of the particles in the collection.\n\nShould be used internally when overriding Base.show for concrete implementations of AbstractParticleCollection.\n\nThis is not exported.\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#All-Particles","page":"Particle Collections","title":"All Particles","text":"","category":"section"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"AllParticles\nparticle_collection\nBase.copy!(dst::AbstractParticles, src::AllParticles, props=nothing)","category":"page"},{"location":"particlecollection/#CosmoParticles.AllParticles","page":"Particle Collections","title":"CosmoParticles.AllParticles","text":"AllParticles{APC} <: AbstractParticles where {APC<:AbstractParticleCollection}\n\nCombines the particles of different types from a particle collection lazily.\n\nThe property arrays of the collection's particles are concatenated lazily with LazyArrays.jl. Scalar properties (e.g. mass for equal-mass particles) are repeated according to the particle number of the given particle type with FillArrays.jl. Properties that only exist for one of the particle types are repeated as missing values in the same way as scalar properties.\n\nUsage\n\nThe individual properties of AllParticles can be converted as regular arrays with Array(ap.pos) and all or selected particle properties can be converted to a Particles object with Particles(ap), where all lazy arrays are materialized as Arrays. AllParticles cannot be sorted, filtered, or copied. In-place modifications are possible, such as rotate!, translate!, or to_comoving.\n\nwarning: In-place modifications\nModifying an AllParticles object in-place results in the modification of the underlying particle collection! To prevent bugs or unexpected behavior, it is advised to modify the particle collection instead and then obtain the object through pc.all or AllParticles(pc) (these are equivalent).\n\nThe lazy concatenation occurs only when the property is needed and is only performed once. Note that this means that calling pc.all.prop multiple times results in the given property being lazily concatenated every time. As long as the property array pointers of the particle collection are not modified (e.g. by sort! or filter!), it is possible to reuse an object ap = pc.all without the need of regenerating the concatenated arrays.\n\nwarning: Modifying the underlying particle collection\nAfter modifying the property array pointers of a particle collection (e.g. by sort! or filter!), any already created AllParticles objects from that collection may have lazy arrays pointing to the old, non-modified arrays. When this happens, create a new object through pc.all or AllParticles(pc).\n\nExample\n\njulia> pc::ParticleCollection\nParticleCollection\ndm: 100 Particles\n id mass pos\ngas: 50 Particles\n id mass pos temp\n\njulia> ap = AllParticles(pc) # equivalent to ap = pc.all\nall: 150 Particles\n id mass pos temp\n\njulia> p = Particles(ap) # p is detached from pc and therefore modifiable\nall: 150 Particles\n id mass pos temp\n\njulia> sort!(p, :id)\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.particle_collection","page":"Particle Collections","title":"CosmoParticles.particle_collection","text":"particle_collection(p::AllParticles)\n\nReturns the underlying particle collection.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particlecollection/#Base.copy!","page":"Particle Collections","title":"Base.copy!","text":"Base.copy!(dst::AbstractParticles, src::AllParticles[, props])\n\nCopies the materialized particle properties to another particle object.\n\nTo only copy certain properties, props can be passed as a vector of Symbols. The dst cannot be of type AllParticles.\n\n\n\n\n\n","category":"function"},{"location":"particles/","page":"Particles","title":"Particles","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"particles/","page":"Particles","title":"Particles","text":"A set of objects with different properties are represented by subtypes of AbstractParticles. While not absolutely necessary, these kind of objects generally have IDs, positions, and velocity as properties. In the context of cosmological simulations, this applies to particle and galaxy data.","category":"page"},{"location":"particles/","page":"Particles","title":"Particles","text":"For an example implementation of a concrete subtype of AbstractParticles, see the source code of Particles.","category":"page"},{"location":"particles/","page":"Particles","title":"Particles","text":"AbstractParticles\nParticles\nParticles(type)\nParticles(p::AllParticles, props=nothing)\nCosmoParticles.get_props\nCosmoParticles.particle_name\nCosmoParticles.particle_number\nCosmoParticles.show_properties(io::IO, mime::AbstractString, p::AbstractParticles)","category":"page"},{"location":"particles/#CosmoParticles.AbstractParticles","page":"Particles","title":"CosmoParticles.AbstractParticles","text":"abstract type AbstractParticles end\n\nAbstract supertype for storing particle data efficiently in arrays.\n\nParticles generally have IDs, positions, and velocities as properties. The properties are expected to be stored in a Dict{Symbol,Any} as vectors of length N, matrices of size mN, or as scalars (when the property is equal for all particles).\n\nThe inbuilt functionality of AbstractParticles includes accessing and setting properties via the following syntax:\n\np.id = [1, 2, 3]\np[:id] === p.id\n\nIf the struct has additional fields, these can also be accessed by p.field, but not by p[:field]. The latter syntax can only be used to access the particle properties.\n\nProperty keys\n\n:id: vector of IDs\n:pos: 2N or 3N matrix with positions\n:vel: 2N or 3N matrix with velocities\n\nAny arrays may be of the type AbstractArray, provided the arrays are 1-indexed.\n\nMethods\n\nThe methods Base.keys, Base.values, Base.haskey, Base.empty, Base.empty!, Base.isempty, and Base.copy! are forwarded to the property Dict.\n\nConcrete types of AbstractParticles should have the following methods implemented (also see the implementation of Particles):\n\nBase.copy: returns new object containing a copy of the Dict\nBase.empty: returns an identical object, but with an empty Dict\nBase.:(==): should call Base.isequal to prevent obtaining missing results for properties with missing values (relevant for AllParticles)\nCosmoParticles.particle_name: returns the name of the struct to be printed via Base.show\nBase.propertynames: implement this if there are additional struct fields\nBase.show(io, mime, p)\n\n\n\n\n\n","category":"type"},{"location":"particles/#CosmoParticles.Particles","page":"Particles","title":"CosmoParticles.Particles","text":"struct Particles <: AbstractParticles\n    type::Symbol\n    props::Dict{Symbol,Any}\nend\n\nParticles of a certain type (typically something like :dm or :gas in the cosmological context) with their properties.\n\nThe following naming convention is to be used for specific properties:\n\n:id: vector of IDs\n:pos: 2N or 3N matrix with positions\n:vel: 2N or 3N matrix with velocities\n:mass: vector of masses or a scalar if all particles have the same mass\n:temp: vector of temperatures\n\n\n\n\n\n","category":"type"},{"location":"particles/#CosmoParticles.Particles-Tuple{Any}","page":"Particles","title":"CosmoParticles.Particles","text":"Particles(type[, pairs::Pair...])\n\nCreate a Particles object with the given type and pairs of Symbol to the property values. These are passed to the underlying Dict. If no pairs are passed to the method, an empty Dict is created.\n\n\n\n\n\n","category":"method"},{"location":"particles/#CosmoParticles.Particles-2","page":"Particles","title":"CosmoParticles.Particles","text":"Particles(p::AllParticles, props=nothing)\n\nMaterializes the particle properties in a new particle object of type :all.\n\nTo only copy certain properties, props can be passed as a tuple of Symbols.\n\n\n\n\n\n","category":"type"},{"location":"particles/#CosmoParticles.get_props","page":"Particles","title":"CosmoParticles.get_props","text":"CosmoParticles.get_props(p::AbstractParticles)\n\nReturn the property Dict belonging to the particles.\n\nThis returns p.props by default if not overridden.\n\nThis is not exported and should not be used outside of the defining files for particle types.\n\n\n\n\n\n","category":"function"},{"location":"particles/#CosmoParticles.particle_name","page":"Particles","title":"CosmoParticles.particle_name","text":"CosmoParticles.particle_name(p::AbstractParticles)\n\nReturns the name of the particle type, which is used when printing an object of this type via Base.show.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particles/#CosmoParticles.particle_number","page":"Particles","title":"CosmoParticles.particle_number","text":"CosmoParticles.particle_number(p::AbstractParticles)\n\nReturns the number of particles by determining the length of one of the property arrays.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particles/#CosmoParticles.show_properties-Tuple{IO, AbstractString, AbstractParticles}","page":"Particles","title":"CosmoParticles.show_properties","text":"CosmoParticles.show_properties(io::IO, mime, p::AbstractParticles)\n\nPrints the number of particles, the name of the type, and the property names.\n\nShould be used internally when overriding Base.show for concrete implementations of AbstractParticles.\n\nThis is not exported.\n\n\n\n\n\n","category":"method"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"geometry/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"To filter particles in a particular volume, such as a cube, a sphere, or a cylinder, geometries can be used. This package provides a variety of different geometries for multiple dimensions, including the following:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Hyperrectangle\n3D Rectangular Cuboid\n2D Rectangle\nHypersphere\n3D Sphere\n2D Circle\nCylinder (standing cylinder aligned with the z axis and arbitrary orientation)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"AbstractCosmoGeometry\nCosmoParticles.geometry_enclosing_corners\nCosmoParticles.geometry_enclosing_center\nCosmoParticles.mask_in\nCosmoHyperrectangle\nCosmoCuboid\nCosmoRectangle\nCosmoHypercube\nCosmoCube\nCosmoSquare\nCosmoHypersphere\nCosmoHypersphere(::Integer, ::Number)\nCosmoSphere\nCosmoSphere(::Number)\nCosmoCircle\nCosmoCircle(::Number)\nCosmoCylinder\nCosmoCylinder(::CosmoStandingCylinder)\nCosmoStandingCylinder\nCosmoStandingCylinder(::CosmoCylinder)","category":"page"},{"location":"geometry/#CosmoParticles.AbstractCosmoGeometry","page":"Geometry","title":"CosmoParticles.AbstractCosmoGeometry","text":"abstract type AbstractCosmoGeometry end\n\nAbstract type for (multi-dimensional) geometry volumes, particularly for filtering with filter.\n\nAny subtypes of AbstractCosmoGeometry have to implement the following methods:\n\nCosmoParticles.geometry_enclosing_corners\nCosmoParticles.geometry_enclosing_center\nCosmoParticles.mask_in!\nCosmoParticles.translate\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.geometry_enclosing_corners","page":"Geometry","title":"CosmoParticles.geometry_enclosing_corners","text":"geometry_enclosing_corners(geo::AbstractCosmoGeometry)\n\nReturn the lower left and upper right corners of the enclosing box of the geometry as a tuple of vectors.\n\nThe enclosing box is not necessarily the tightest fitting box.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.geometry_enclosing_center","page":"Geometry","title":"CosmoParticles.geometry_enclosing_center","text":"geometry_enclosing_center(geo::AbstractCosmoGeometry)\n\nReturn the center of the enclosing box of the geometry as a vector.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.mask_in","page":"Geometry","title":"CosmoParticles.mask_in","text":"mask_in(pos::AbstractMatrix{<:Number}, geo::AbstractCosmoGeometry)\n\nReturn the BitArray mask of the positions (mathrmdims  N) located within the geometry.\n\nCalls mask_in! by default.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoHyperrectangle","page":"Geometry","title":"CosmoParticles.CosmoHyperrectangle","text":"struct CosmoHyperrectangle{T,N} <: AbstractCosmoGeometry where {T<:Number}\n    lowerleft::Vector{T}\n    upperright::Vector{T}\nend\n\nN-dimensional hyperrectangle aligned with the coordinate system axes given by its lower left and upper right corners.\n\nThe dimensions of space are given by N.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoCuboid","page":"Geometry","title":"CosmoParticles.CosmoCuboid","text":"CosmoCuboid{T} = CosmoHyperrectangle{T,3}\n\nAlias for a 3D CosmoHyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoRectangle","page":"Geometry","title":"CosmoParticles.CosmoRectangle","text":"CosmoRectangle{T} = CosmoHyperrectangle{T,2}\n\nAlias for a 2D CosmoHyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoHypercube","page":"Geometry","title":"CosmoParticles.CosmoHypercube","text":"CosmoHypercube(center::AbstractVector{<:Number}, radius::Number)\n\nReturn a cubic CosmoCuboid centered around center, with equal sidelengths.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoCube","page":"Geometry","title":"CosmoParticles.CosmoCube","text":"CosmoCube(center::AbstractVector{<:Number}, radius::Number)\n\nReturn a cubic CosmoCuboid centered around center, with equal sidelengths.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoSquare","page":"Geometry","title":"CosmoParticles.CosmoSquare","text":"CosmoSquare(center::AbstractVector{<:Number}, radius::Number)\n\nReturn a square CosmoRectangle centered around center, with equal sidelengths.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoHypersphere","page":"Geometry","title":"CosmoParticles.CosmoHypersphere","text":"struct CosmoHypersphere{T,N} <: AbstractCosmoGeometry where {T<:Number}\n    center::Vector{T}\n    radius::T\nend\n\nN-dimensional hypersphere given by its center and radius.\n\nIf different types are passed to the constructor, the types will be promoted without throwing an error.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoHypersphere-Tuple{Integer, Number}","page":"Geometry","title":"CosmoParticles.CosmoHypersphere","text":"CosmoHypersphere(N::Integer, radius::T)\n\nReturns an N-dimensional hypersphere around the origin.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#CosmoParticles.CosmoSphere","page":"Geometry","title":"CosmoParticles.CosmoSphere","text":"CosmoSphere{T} = CosmoHypersphere{T,3}\n\nAlias for a 2D CosmoHypersphere.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoSphere-Tuple{Number}","page":"Geometry","title":"CosmoParticles.CosmoSphere","text":"CosmoSphere(radius::T)\n\nReturns a sphere around the origin.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#CosmoParticles.CosmoCircle","page":"Geometry","title":"CosmoParticles.CosmoCircle","text":"CosmoCircle{T} = CosmoHypersphere{T,2}\n\nAlias for a 2D CosmoHypersphere.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoCircle-Tuple{Number}","page":"Geometry","title":"CosmoParticles.CosmoCircle","text":"CosmoCircle(radius::T)\n\nReturns a circle around the origin.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#CosmoParticles.CosmoCylinder","page":"Geometry","title":"CosmoParticles.CosmoCylinder","text":"struct CosmoCylinder{T} <: AbstractCosmoGeometry where {T<:Number}\n    startpos::Vector{T}\n    endpos::Vector{T}\n    radius::T\nend\n\nCylinder given by its end points startpos and endpos and radius.\n\nIf different types are passed to the constructor, the types will be promoted without throwing an error.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoCylinder-Tuple{CosmoStandingCylinder}","page":"Geometry","title":"CosmoParticles.CosmoCylinder","text":"CosmoCylinder(c::CosmoStandingCylinder)\n\nCreate a cylinder from a standing cylinder.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#CosmoParticles.CosmoStandingCylinder","page":"Geometry","title":"CosmoParticles.CosmoStandingCylinder","text":"struct CosmoStandingCylinder{T} <: AbstractCosmoGeometry where {T<:Number}\n    center::Vector{T}\n    height::T\n    radius::T\nend\n\nStanding cylinder given by its center, height, and radius.\n\nStanding means that the cylinder is oriented such that its axis is aligned with the z axis. If different types are passed to the constructor, the types will be promoted without throwing an error.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoStandingCylinder-Tuple{CosmoCylinder}","page":"Geometry","title":"CosmoParticles.CosmoStandingCylinder","text":"CosmoStandingCylinder(c::CosmoCylinder)\n\nCreate a standing cylinder from a cylinder.\n\nThe end positions of the cylinder have to have the same x and y coordinates.\n\n\n\n\n\n","category":"method"},{"location":"properties/","page":"Properties","title":"Properties","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"properties/#Properties","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"properties/","page":"Properties","title":"Properties","text":"sumprop\nmeanprop\nmeanpos\nmeanvel\nangmom\nangmomtot\nangmomtot_stable\ncolnorm\ncolnorm2\ncoldot\ncolcross","category":"page"},{"location":"properties/#CosmoParticles.sumprop","page":"Properties","title":"CosmoParticles.sumprop","text":"sumprop(p::AbstractParticles, prop::Symbol)\n\nReturns the sum of the specified property over all particles.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.meanprop","page":"Properties","title":"CosmoParticles.meanprop","text":"meanprop(p::AbstractParticles, prop::Symbol; massprop=:mass, massweighted::Bool=true)\n\nReturns the mean of the specified property over all particles.\n\nThe mean can be weighted by the mass.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.meanpos","page":"Properties","title":"CosmoParticles.meanpos","text":"meanpos(p::AbstractParticles, prop::Symbol=:pos; massprop=:mass, massweighted=true)\n\nReturns the mean of the particles' positions.\n\nThe mean can be weighted by the mass.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.meanvel","page":"Properties","title":"CosmoParticles.meanvel","text":"meanvel(p::AbstractParticles, prop::Symbol=:pos; massprop=:mass, massweighted=true)\n\nReturns the mean of the particles' velocities.\n\nThe mean can be weighted by the mass.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.angmom","page":"Properties","title":"CosmoParticles.angmom","text":"angmom(p::AbstractParticles)\n\nReturns the individual angular momenta of the particles.\n\nIf angmomprop is a Symbol, the already computed angular momenta are returned directly if they exist.\n\nKeyword Arguments\n\norigin=Nothing: origin of the coordinate system for the computation of the angular momentum\nvelorigin=Nothing: relative velocity zero-point, oftentimes the velocity of the center of mass\nposprop=:pos: property name of the position\nvelprop=:vel: property name of the velocity\nmassprop=:mass: property name of the mass\nangmomprop=nothing: property name of the angular momentum - the method checks whether it already exists or not. Warning: The method assumes the already saved property to have used the same origin and velorigin.\n\n\n\n\n\nangmom(pos::AbstractMatrix, vel::AbstractMatrix, mass; origin=nothing, velorigin=nothing)\n\nReturns the angular momentum based on the positions, velocities, and masses.\n\nBoth input matrices need to have the same dimensions 3  N. The mass can be a vector or a scalar value (useful if all particles have the same mass).\n\nThe coordinate system's origin can be passed as a vector of length 3, as well as the velocity origin, which determines the relative velocity at which the angular momentum should be determined. Typically, this will be the velocity of the center of mass.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.angmomtot","page":"Properties","title":"CosmoParticles.angmomtot","text":"angmomtot(p::AbstractParticles)\n\nReturns the total angular momentum of the particles.\n\nIf angmomprop is a Symbol, the total angular momentum is computed from the already existing angular momenta.\n\nKeyword Arguments\n\norigin=Nothing: origin of the coordinate system for the computation of the angular momentum\nvelorigin=Nothing: relative velocity zero-point, oftentimes the velocity of the center of mass\nposprop=:pos: property name of the position\nvelprop=:vel: property name of the velocity\nmassprop=:mass: property name of the mass\nangmomprop=nothing: property name of the angular momentum - the method checks whether it already exists or not. Warning: The method assumes the already saved property to have used the same origin and velorigin.\n\n\n\n\n\nangmomtot(pos::AbstractMatrix, vel::AbstractMatrix, mass; origin=nothing, velorigin=nothing)\n\nReturns the total angular momentum based on the positions, velocities, and masses.\n\nBoth input matrices need to have the same dimensions 3  N. The mass can be a vector or a scalar value (useful if all particles have the same mass).\n\nThe coordinate system's origin can be passed as a vector of length 3, as well as the velocity origin, which determines the relative velocity at which the angular momentum should be determined. Typically, this will be the velocity of the center of mass.\n\nThis method never allocates the full angular momentum matrix for all particles like angmom does. Use this when the individual particle angular momenta are not needed.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.angmomtot_stable","page":"Properties","title":"CosmoParticles.angmomtot_stable","text":"angmomtot_stable(pos::AbstractMatrix, vel::AbstractMatrix, mass; origin=nothing, velorigin=nothing)\n\nReturns the total angular momentum based on the positions, velocities, and masses, like angmomtot.\n\nUses the stable summation algorithm Base.sum for the summation, but is almost three times slower than angmomtot.\n\nSee angmomtot for the available keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.colnorm","page":"Properties","title":"CosmoParticles.colnorm","text":"colnorm(a::AbstractMatrix[, origin::AbstractVector])\n\nReturns a new Vector with the columnwise norms of a around origin.\n\nThis method does not check for overflow of the squared norm.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.colnorm2","page":"Properties","title":"CosmoParticles.colnorm2","text":"colnorm2(a::AbstractMatrix[, origin:AbstractVector])\n\nReturns a new Vector with the columnwise squared norms of a around origin.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.coldot","page":"Properties","title":"CosmoParticles.coldot","text":"coldot(a::AbstractMatrix, b::AbstractMatrix)\n\nReturns the dot products of the matrix columns as a new matrix.\n\nBoth input matrices need to have the same dimensions d  N, representing N d-dimensional vectors.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.colcross","page":"Properties","title":"CosmoParticles.colcross","text":"colcross(a::AbstractMatrix, b::AbstractMatrix)\n\nReturns the cross products of the matrix columns as a new matrix.\n\nBoth input matrices need to have the same dimensions 3  N.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"#CosmoParticles","page":"Home","title":"CosmoParticles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CosmoParticles provides structs and a clean interface for working with sets of particles and galaxies that have individual properties, especially made for dealing with the data extracted from cosmological simulations.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Note that this package usually does not have to be directly installed by the user, instead install any of the implementing packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is only available through the local registry CosmoSimsRegistry, for which access first needs to be granted. It is recommended that an ssh key pair is created with the following command (which can be saved as id_rsa_gitlab, for example):","category":"page"},{"location":"","page":"Home","title":"Home","text":"ssh-keygen -t rsa -b 4096 -m PEM","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the package manager to pick up on the ssh key, either ssh-agent has to be used, or the following two environment variables should be set (e.g., by setting them in the .bashrc file with export in front of each line):","category":"page"},{"location":"","page":"Home","title":"Home","text":"SSH_KEY_PATH=~/.ssh/id_rsa_gitlab\nSSH_PUB_KEY_PATH=~/.ssh/id_rsa_gitlab.pub","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package registry can be loaded from the Julia REPL with the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"registry add https://gitlab.com/juliacosmosims/CosmoSimsRegistry\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This only needs to be done once per Julia installation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latest version of the package is available for Julia 1.7 and newer versions and can be installed with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"CosmoParticles\")","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/#Transformations","page":"Operations","title":"Transformations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"rotate\nLinearAlgebra.rotate!\ntranslate\ntranslate!\ntranslate_periodic\ntranslate_periodic!\ntranslate_periodic_to_center\ntranslate_periodic_to_center!\nto_comoving\nto_comoving!\nto_physical\nto_physical!","category":"page"},{"location":"operations/#CosmoParticles.rotate","page":"Operations","title":"CosmoParticles.rotate","text":"rotate(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, prop)\nrotate(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, props=[:pos, :vel])\n\nRotates the specified properties props of the particles p by the rotation matrix rotmat.\n\nCreates a copy of the particles with only new pointers to the rotated properties (by default position and velocity). This means that mutations to other properties will affect both the original particles as well as the rotated copied particles. The properties should be given as a single Symbol, or a vector of Symbols. Only the existing quantities will be rotated (e.g., this method does not throw an error if velocities are not given for the particles).\n\n\n\n\n\nrotate(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, prop)\nrotate(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, props=[:pos, :vel])\n\nRotates the specified properties props of the particles in the collection by the rotation matrix rotmat.\n\nCreates a copy of the particle collection with only new pointers to the rotated particles (by default position and velocity). The properties should be given as a single Symbol, or a vector of Symbols.\n\n\n\n\n\n","category":"function"},{"location":"operations/#LinearAlgebra.rotate!","page":"Operations","title":"LinearAlgebra.rotate!","text":"LinearAlgebra.rotate!(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, props=[:pos, :vel])\nLinearAlgebra.rotate!(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, prop)\nLinearAlgebra.rotate!(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, props=[:pos, :vel])\nLinearAlgebra.rotate!(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, prop)\n\nIn-place version of rotate.\n\nThis function is reexported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate","page":"Operations","title":"CosmoParticles.translate","text":"translate(geo::AbstractCosmoGeometry, Δx::AbstractVector{<:Number})\n\nReturns a new geometry translated by Δx.\n\n\n\n\n\ntranslate(p::AbstractParticles, Δx, prop::Symbol=:pos)\n\nTranslates the specified property of the particles p by Δx.\n\nCreates a copy of the particles with only new pointers to the translated property. Typically, Δx will be an AbstractVector, e.g., for positions or velocities.\n\n\n\n\n\ntranslate(pc::AbstractParticleCollection, Δx::AbstractVector{<:Number}, prop::Symbol=:pos)\n\nTranslates the specified property of the particles in the collection pc by Δx.\n\nCreates a copy of the particle collection with only new pointers to the translated properties for the particles. Typically, Δx will be an AbstractVector, e.g., for positions or velocities.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate!","page":"Operations","title":"CosmoParticles.translate!","text":"translate!(p::AbstractParticles, Δx, prop::Symbol=:pos)\ntranslate!(pc::AbstractParticleCollection, Δx, prop::Symbol=:pos)\n\nIn-place version of translate.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate_periodic","page":"Operations","title":"CosmoParticles.translate_periodic","text":"translate_periodic(p::AbstractParticles, centerpos, period, prop::Symbol=:pos)\ntranslate_periodic(pc::AbstractParticleCollection, centerpos, period, prop::Symbol=:pos)\n\nTranslates the specified property of the particles or collection by the period such that all particles are the closest to centerpos as possible.\n\nCreates a copy of the particles or the collection with only new pointers to the translated property. Typically, centerpos will be an AbstractVector, e.g., for positions, and period can be a Number or AbstractVector, depending on if the period is the same for all dimensions or if they are different.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate_periodic!","page":"Operations","title":"CosmoParticles.translate_periodic!","text":"translate_periodic!(p::AbstractParticles, centerpos, period, prop::Symbol=:pos)\ntranslate_periodic!(pc::AbstractParticleCollection, centerpos, period, prop::Symbol=:pos)\n\nIn-place version of translate_periodic.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate_periodic_to_center","page":"Operations","title":"CosmoParticles.translate_periodic_to_center","text":"translate_periodic_to_center(p::AbstractParticles, centerpos, period, prop::Symbol=:pos)\ntranslate_periodic_to_center(pc::AbstractParticleCollection, centerpos, period, prop::Symbol=:pos)\n\nTranslates the specified property of the particles or collection to place centerpos at the origin.\n\nThe particles are translated periodically to place them closest to centerpos.\n\nCreates a copy of the particles or the collection with only new pointers to the translated property. Typically, centerpos will be an AbstractVector, e.g., for positions, and period can be a Number or AbstractVector, depending on if the period is the same for all dimensions or if they are different.\n\nAlso see translate_periodic.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate_periodic_to_center!","page":"Operations","title":"CosmoParticles.translate_periodic_to_center!","text":"translate_periodic_to_center!(p::AbstractParticles, centerpos, period, prop::Symbol=:pos)\ntranslate_periodic_to_center!(pc::AbstractParticleCollection, centerpos, period, prop::Symbol=:pos)\n\nIn-place version of translate_periodic_to_center.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_comoving","page":"Operations","title":"CosmoParticles.to_comoving","text":"to_comoving(p::AbstractParticles, z::Real; propexp=[(:pos, 1), (:vel, 1)])\nto_comoving(pc::AbstractParticleCollection; propexp=[(:pos, 1), (:vel, 1)])\n\nCreate new particles or collection with particle properties converted from physical to comoving.\n\nThe properties and the positional exponent of their units (e.g., 1 for positions, 3 for volumes, and -3 for densities) are passed as the keyword argument propexp as a vector of tuples. The redshift z is obtained from redshift for the particle collection.\n\nThe properties are multiplied by (1 + z)^n where n is the positional exponent.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_comoving!","page":"Operations","title":"CosmoParticles.to_comoving!","text":"to_comoving!(p::AbstractParticles, z::Real; propexp=[(:pos, 1), (:vel, 1)])\nto_comoving!(pc::AbstractParticleCollection; propexp=[(:pos, 1), (:vel, 1)])\n\nConvert particle properties from physical to comoving in-place.\n\nIn-place version of to_comoving.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_physical","page":"Operations","title":"CosmoParticles.to_physical","text":"to_physical(p::AbstractParticles, z::Real; propexp=[(:pos, 1), (:vel, 1)])\nto_physical(pc::AbstractParticleCollection; propexp=[(:pos, 1), (:vel, 1)])\n\nCreate new particles or collection with particle properties converted from comoving to physical.\n\nThe properties and the positional exponent of their units (e.g., 1 for positions, 3 for volumes, and -3 for densities) are passed as the keyword argument propexp as a vector of tuples. The redshift z is obtained from redshift for the particle collection.\n\nThe properties are multiplied by (1 + z)^-n where n is the positional exponent.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_physical!","page":"Operations","title":"CosmoParticles.to_physical!","text":"to_physical!(p::AbstractParticles, z::Real; propexp=[(:pos, 1), (:vel, 1)])\nto_physical!(pc::AbstractParticleCollection; propexp=[(:pos, 1), (:vel, 1)])\n\nConvert particle properties from comoving to physical in-place.\n\nIn-place version of to_physical.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Further-Operations","page":"Operations","title":"Further Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Base.sort\nBase.sort!\nBase.filter\nBase.filter!\nBase.delete\nBase.delete!\nCosmoParticles.applyind\nCosmoParticles.applyind!\nCosmoParticles.removeind\nCosmoParticles.removeind!\nCosmoParticles.findall_in\nCosmoParticles.findall_in_sorted","category":"page"},{"location":"operations/#Base.sort","page":"Operations","title":"Base.sort","text":"Base.sort(p::AbstractParticles, prop::Symbol; affect=keys(p), kwargs...)\n\nCreate new particles with the particles sorted according to the specified property.\n\nAll property arrays of the particles are rearranged according to the property being sorted. If the keyword argument affect is a non-empty vector of Symbols, only those properties are rearranged and added to the newly created particles object. The other keyword arguments are passed on to Base.sortperm.\n\nThe sorting algorithm for unitful properties may also be RadixSort from SortingAlgorithms.jl.\n\n\n\n\n\nBase.sort(pc::AbstractParticleCollection, prop::Symbol; [affect,] kwargs...)\n\nCreate new particle collection with the particles in the collection sorted by calling Base.sort on each of the particles objects.\n\nIf the keyword argument affect is a non-empty vector of Symbols, only the affected properties are kept for the particles. The specified affected properties do not have to be available for all particles. For collections of Particles, affect can alternatively be a vector of tuples in the following form: [(:dm, [:id, :pos, :mass]), (:gas, [:id, :pos, :mass, :temp])].\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.sort!","page":"Operations","title":"Base.sort!","text":"Base.sort!(p::AbstractParticles, prop::Symbol; kwargs...)\n\nSort the particles in-place according to the specified property.\n\nAll property arrays of the particles are rearranged in-place according to the property being sorted. The keyword arguments are passed on to Base.sortperm.\n\nThe sorting algorithm for unitful properties may also be RadixSort from SortingAlgorithms.jl.\n\n\n\n\n\nBase.sort!(pc::AbstractParticleCollection, prop::Symbol; kwargs...)\n\nSort the particles in the collection in-place by calling Base.sort! on each of the Particles objects.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.filter","page":"Operations","title":"Base.filter","text":"Base.filter(f, p::AbstractParticles; affect=keys(p))\nBase.filter(f, pc::AbstractParticleCollection[; affect])\n\nCreate new particles or collection with the particles filtered by a mask returned by the function f.\n\nThe function f takes the particles as argument and has to either return a BitArray mask with a length of the number of particles or an array of indices. If the keyword argument affect is a non-empty vector of Symbols, only those properties are filtered and added to the newly created particles object.\n\nFor collections of Particles, affect can alternatively be a vector of tuples in the following form: [(:dm, [:id, :pos, :mass]), (:gas, [:id, :pos, :mass, :temp])].\n\n\n\n\n\nBase.filter(p::AbstractParticles, ids; affect=keys(p))\nBase.filter(pc::AbstractParticleCollection; ids[, affect])\n\nCreate new particles or collection with them filtered by keeping only the particles with the given IDs.\n\nIf the keyword argument affect is a non-empty vector of Symbols, only those properties are filtered and added to the newly created particles object.\n\nFor collections of Particles, affect can alternatively be a vector of tuples in the following form: [(:dm, [:id, :pos, :mass]), (:gas, [:id, :pos, :mass, :temp])].\n\n\n\n\n\nBase.filter(p::AbstractParticles, geo::AbstractCosmoGeometry, prop::Symbol=:pos; affect=keys(p))\nBase.filter(pc::AbstractParticleCollection, geo::AbstractCosmoGeometry, prop::Symbol=:pos[; affect])\n\nCreate new particles or collection with them filtered by keeping only the particles inside the given AbstractCosmoGeometry.\n\nThe geometry filter is applied to the property specified. If the keyword argument affect is a non-empty vector of Symbols, only those properties are filtered and added to the newly created particles object.\n\nFor collections of Particles, affect can alternatively be a vector of tuples in the following form: [(:dm, [:id, :pos, :mass]), (:gas, [:id, :pos, :mass, :temp])].\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.filter!","page":"Operations","title":"Base.filter!","text":"Base.filter!(f, p::AbstractParticles)\nBase.filter!(f, pc::AbstractParticleCollection)\n\nFilter the particles or collection in-place by masks returned by the function f.\n\nThe function f takes a particles object as argument and has to either return a BitArray mask with a length of the number of particles or an array of indices.\n\n\n\n\n\nBase.filter!(p::AbstractParticles; ids)\nBase.filter!(pc::AbstractParticleCollection; ids)\n\nFilter the particles or collection in-place by keeping only the particles with the given IDs.\n\n\n\n\n\nBase.filter!(p::AbstractParticles, geo::AbstractCosmoGeometry, prop::Symbol=:pos)\nBase.filter!(pc::AbstractParticleCollection, geo::AbstractCosmoGeometry, prop::Symbol=:pos)\n\nFilter the particles or collection in-place by keeping only the particles inside the given AbstractCosmoGeometry.\n\nThe geometry filter is applied to the property specified.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.delete!","page":"Operations","title":"Base.delete!","text":"Base.delete!(p::AbstractParticles; ids)\nBase.delete!(pc::AbstractParticleCollection; ids)\n\nFilter the particles or collection in-place by removing all particles with the given IDs.\n\n\n\n\n\nBase.delete!(p::AbstractParticles, geo::AbstractCosmoGeometry, prop::Symbol=:pos)\nBase.delete!(pc::AbstractParticleCollection, geo::AbstractCosmoGeometry, prop::Symbol=:pos)\n\nFilter the particles or collection in-place by keeping only the particles outside the given AbstractCosmoGeometry.\n\nThe geometry filter is applied to the property specified.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.applyind","page":"Operations","title":"CosmoParticles.applyind","text":"CosmoParticles.applyind(p::AbstractParticles, ind::Union{AbstractVector,Colon}; affect=keys(p))\n\nCreate new particles with the given indices or mask applied to all particle properties.\n\nThis can also be called by the simple syntax p[ind]. If the keyword argument affect is a vector of Symbols, only those properties are indexed into and added to the newly created particles object.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.applyind!","page":"Operations","title":"CosmoParticles.applyind!","text":"CosmoParticles.applyind!(p::AbstractParticles, ind::Union{AbstractVector,Colon})\n\nIn-place application of indices or mask to all particle properties.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.removeind","page":"Operations","title":"CosmoParticles.removeind","text":"CosmoParticles.removeind(p::AbstractParticles, ind::AbstractVector; affect=keys(p))\n\nCreate new particles without the given indices or mask applied to all particle properties.\n\nThis can also be called by the simple syntax p[ind]. If the keyword argument affect is a vector of Symbols, only those properties are indexed into and added to the newly created particles object.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.removeind!","page":"Operations","title":"CosmoParticles.removeind!","text":"CosmoParticles.removeind!(p::AbstractParticles, ind::AbstractVector)\n\nIn-place removal of indices to all particle properties.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.findall_in","page":"Operations","title":"CosmoParticles.findall_in","text":"CosmoParticles.findall_in(a::AbstractVector, set)\n\nReturn all indices of a that are in set.\n\nIf both a and set are sorted AbstractVectors, then the optimized findall_in_sorted is called. Otherwise, a Set is constructed from the Vector to perform the checks with in.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.findall_in_sorted","page":"Operations","title":"CosmoParticles.findall_in_sorted","text":"CosmoParticles.findall_in_sorted(a::AbstractVector, set::AbstractVector)\n\nReturn all indices of a that are in set, where both a and set are assumed to be sorted.\n\nThis uses an optimized algorithm that is faster than creating a Set from set and performing checks with in.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Internals","page":"Operations","title":"Internals","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"CosmoParticles.matrix_rotate\nCosmoParticles.matrix_rotate!\nCosmoParticles._applyind\nCosmoParticles._removeind\nCosmoParticles._translate_periodic","category":"page"},{"location":"operations/#CosmoParticles.matrix_rotate","page":"Operations","title":"CosmoParticles.matrix_rotate","text":"CosmoParticles.matrix_rotate(vals::AbstractMatrix{<:Number}, rotmat::AbstractMatrix{<:Real})\n\nReturns vals rotated by the rotation matrix rotmat by regular matrix multiplication. Works for any dimensions and is optimized for unitful arrays.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.matrix_rotate!","page":"Operations","title":"CosmoParticles.matrix_rotate!","text":"CosmoParticles.matrix_rotate!(vals::AbstractMatrix{<:Number}, rotmat::AbstractMatrix{<:Real})\n\nIn-place version of CosmoParticles.matrix_rotate, overwriting vals.\n\nThis is not exported.\n\n\n\n\n\nCosmoParticles.matrix_rotate!(dst::AbstractMatrix{<:Number}, vals::AbstractMatrix{<:Number}, rotmat::AbstractMatrix{<:Real})\n\nIn-place version of CosmoParticles.matrix_rotate, overwriting dst.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles._applyind","page":"Operations","title":"CosmoParticles._applyind","text":"CosmoParticles._applyind(a, ind::Union{AbstractVector,Colon})\n\nApply indices or mask to a Number, Vector, or Matrix.\n\nOther possible types: Nothing\n\nThe following indexing is applied:\n\na::Number: a is returned directly.\na::Vector: a[ind] is returned.\na::Matrix: a[:, ind] is returned.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles._removeind","page":"Operations","title":"CosmoParticles._removeind","text":"CosmoParticles._removeind(a, ind::AbstractVector)\n\nRemove indices of a Number, Vector, or Matrix.\n\nThe vector ind has to contain sorted and unique indices: sort!(unique!(ind)). Additionally, all elements in ind have to be valid indices in a.\n\nOther possible types: Nothing\n\nThe following indexing is applied:\n\na::Number: a is returned directly.\na::Vector: a[Not(ind)] is returned.\na::Matrix: a[:, Not(ind)] is returned.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles._translate_periodic","page":"Operations","title":"CosmoParticles._translate_periodic","text":"_translate_periodic(x::Number, x₀::Number, period::Number, period_half::Number=1//2*period)\n\nReturns the coordinate x shifted by the period if reference coordinate x₀ is on the other side.\n\nFor periodic simulation boxes, the period corresponds to the boxlength.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Utils","title":"Utils","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"CosmoParticles.factor_to_physical\nCosmoParticles.factor_to_comoving\nCosmoParticles.product_preserve_type\nCosmoParticles.product_preserve_type!\nCosmoParticles.ustrip_lazy\nCosmoParticles.uconvert_lazy\nCosmoParticles.uconvert_lazy!","category":"page"},{"location":"utils/#CosmoParticles.factor_to_physical","page":"Utils","title":"CosmoParticles.factor_to_physical","text":"factor_to_physical(z::Real, n::Real)\n\nReturns (1 + z)^-n.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CosmoParticles.factor_to_comoving","page":"Utils","title":"CosmoParticles.factor_to_comoving","text":"factor_to_comoving(z::Real, n::Real)\n\nReturns (1 + z)^n.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CosmoParticles.product_preserve_type","page":"Utils","title":"CosmoParticles.product_preserve_type","text":"CosmoParticles.product_preserve_type(arr::AbstractArray{T}, b::Real) where {T}\n\nMultiply an array with a scalar while preserving the element type of the array.\n\nFor unitful arrays, the scalar factor is converted to the number type of the quantity before multiplying.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CosmoParticles.product_preserve_type!","page":"Utils","title":"CosmoParticles.product_preserve_type!","text":"CosmoParticles product_preserve_type!(arr::AbstractArray{T}, b::Real) where {T}\n\nMultiply an array with a scalar in-place while preserving the element type of the array.\n\nBy converting the scalar factor to the array element type, this can be more performant than a normal broadcasted product. For unitful arrays, the scalar factor is converted to the number type of the quantity before multiplying.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CosmoParticles.ustrip_lazy","page":"Utils","title":"CosmoParticles.ustrip_lazy","text":"CosmoParticles.ustrip_lazy([unit,] a::Number)\nCosmoParticles.ustrip_lazy([unit,] a::AbstractArray)\nCosmoParticles.ustrip_lazy!(unit, a::AbstractArray)\n\nStrips off the units of unitful arrays in a performant way while keeping the number type conserved (not always the case for ustrip).\n\nLike ustrip for normal unitful arrays, but without reallocating non-unitful or lazy arrays. Differently to ustrip, this also works for Numbers and arrays thereof, simply returning the original array.\n\nNote that after calling this method with a different conversion unit, the original array still has the old units, but the numerical values correspond to the new units. This method should always be called as a = uconvert_lazy!(u, a).\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CosmoParticles.uconvert_lazy","page":"Utils","title":"CosmoParticles.uconvert_lazy","text":"CosmoParticles.uconvert_lazy(u::Unitful.Units, a::AbstractArray{<:Quantity})\n\nConverts the unitful array to the given units while preserving the number type passed (not always the case for uconvert).\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CosmoParticles.uconvert_lazy!","page":"Utils","title":"CosmoParticles.uconvert_lazy!","text":"CosmoParticles.uconvert_lazy!(u::Unitful.Units, a::AbstractArray{<:Quantity{T,D,U}}) where {T,D,U}\n\nConverts the unitful array to the specified units in-place.\n\nNote that after calling this method the original array still has the old units, but the numerical values correspond to the new units. This method should always be called as a = uconvert_lazy!(u, a).\n\nThis is not exported.\n\n\n\n\n\n","category":"function"}]
}
