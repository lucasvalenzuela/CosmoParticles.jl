var documenterSearchIndex = {"docs":
[{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"particlecollection/#Particle-Collections","page":"Particle Collections","title":"Particle Collections","text":"","category":"section"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"A set of different particles are represented by subtypes of AbstractParticleCollection. These can have a cosmological redshift attributed to them. In the context of cosmological simulations, this applies to collections of DM, gas, and star particles.","category":"page"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"For an example implementation of a concrete subtype of AbstractParticleCollection, see the source codes of ParticleCollection or RedshiftParticleCollection.","category":"page"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"AbstractParticleCollection\nParticleCollection\nParticleCollection(::Type{<:AbstractParticles})\nParticleCollection(pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles}\nParticleCollection(p::Particles, ps::Particles...)\nRedshiftParticleCollection\nRedshiftParticleCollection(::Type{<:AbstractParticles}, z::Real)\nRedshiftParticleCollection(z::T, pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles,T<:Real}\nRedshiftParticleCollection(z::Real, p::Particles, ps::Particles...)\nredshift\nCosmoParticles.get_particles\nCosmoParticles.show_properties(io::IO, mime::AbstractString, pc::AbstractParticleCollection)","category":"page"},{"location":"particlecollection/#CosmoParticles.AbstractParticleCollection","page":"Particle Collections","title":"CosmoParticles.AbstractParticleCollection","text":"abstract type AbstractParticleCollection{AP} end\n\nAbstract supertype for storing data of multiple particle types.\n\nThe particles are expected to be stored in a Dict{Symbol,<:AbstractParticles}.\n\nThe inbuilt functionality of AbstractParticleCollection includes accessing and setting properties via the following syntax:\n\nP<:AbstractParticles\npc::<:AbstractParticleCollection{P}\np::<:P\npc.dm = p\npc[:dm] === p\n\nIn addition, the following syntax is equivalent to creating an AllParticles object: pc.all. The syntax pc[:all] is not valid, however.\n\nIf the struct has additional fields, these can also be accessed by pc.field, but not by pc[:field]. The latter syntax can only be used to access the particles.\n\nMethods\n\nThe methods Base.keys, Base.values, Base.haskey, Base.empty, Base.empty!, Base.isempty, and Base.copy! are forwarded to the particle Dict.\n\nConcrete types of AbstractParticleCollection should have the following methods implemented (also see the implementation of ParticleCollection):\n\nBase.copy: returns new object containing a copy of the Dict\nBase.empty: returns an identical object, but with an empty Dict\nBase.:(==)\nredshift: implement this if the redshift of the particle collection is non-zero\nBase.propertynames: implement this if there are additional struct fields\nBase.show(io, mime, pc)\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.ParticleCollection","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"struct ParticleCollection{AP<:AbstractParticles} <: AbstractParticleCollection{AP}\n    particles::Dict{Symbol,AP}\nend\n\nBasic particle collection at redshift 0.\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.ParticleCollection-Tuple{Type{<:AbstractParticles}}","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"ParticleCollection(::Type{AP}=Particles) where {AP<:AbstractParticles}\n\nCreate an empty particle collection of the passed type.\n\nBy default, the particle collection is created for the [Particles] type.\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.ParticleCollection-Union{Tuple{Vararg{Pair{Symbol, AP}}}, Tuple{AP}} where AP<:AbstractParticles","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"ParticleCollection(pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles}\n\nCreate a particle collection from pairs of Symbols and particles.\n\nExample\n\nParticleCollection(:dm => Particles(:dm), :gas => Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.ParticleCollection-Tuple{Particles, Vararg{Particles}}","page":"Particle Collections","title":"CosmoParticles.ParticleCollection","text":"ParticleCollection(p::Particles...)\n\nCreate a particle collection from multiple Particles.\n\nThe Dict keys are taken from the Particles type.\n\nExample\n\nParticleCollection(Particles(:dm), Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"struct RedshiftParticleCollection{AP<:AbstractParticles,T<:Real} <: AbstractParticleCollection{AP}\n    z::T\n    particles::Dict{Symbol,AP}\nend\n\nParticle collection at a given redshift.\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection-Tuple{Type{<:AbstractParticles}, Real}","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"RedshiftParticleCollection([::Type{AP}=Particles,] z::T) where {AP<:AbstractParticles,T<:Real}\n\nCreate an empty particle collection of the passed type at redshift z.\n\nBy default, the particle collection is created for the [Particles] type.\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection-Union{Tuple{T}, Tuple{AP}, Tuple{T, Vararg{Pair{Symbol, AP}}}} where {AP<:AbstractParticles, T<:Real}","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"RedshiftParticleCollection(z::T, pairs::Pair{Symbol,AP}...) where {AP<:AbstractParticles,T<:Real}\n\nCreate a particle collection at redshift z from pairs of Symbols and particles.\n\nExample\n\nRedshiftParticleCollection(0.5, :dm => Particles(:dm), :gas => Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.RedshiftParticleCollection-Tuple{Real, Particles, Vararg{Particles}}","page":"Particle Collections","title":"CosmoParticles.RedshiftParticleCollection","text":"RedshiftParticleCollection(z::Real, p::Particles...)\n\nCreate a particle collection at redshift z from multiple Particles.\n\nThe Dict keys are taken from the Particles type.\n\nExample\n\nRedshiftParticleCollection(0.5, Particles(:dm), Particles(:gas))\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#CosmoParticles.redshift","page":"Particle Collections","title":"CosmoParticles.redshift","text":"redshift(pc::AbstractParticleCollection) = 0\n\nReturns the redshift at which the particles are located.\n\nBy default, 0 is returned. This method should be overridden for concrete types of AbstractParticleCollection for which the redshift differs.\n\n\n\n\n\n","category":"function"},{"location":"particlecollection/#CosmoParticles.get_particles","page":"Particle Collections","title":"CosmoParticles.get_particles","text":"get_particles(pc::AbstractParticleCollection)\n\nReturn the particles Dict belonging to the particle collection.\n\nThis returns pc.particles by default if not overridden.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particlecollection/#CosmoParticles.show_properties-Tuple{IO, AbstractString, AbstractParticleCollection}","page":"Particle Collections","title":"CosmoParticles.show_properties","text":"CosmoParticles.show_properties(io::IO, mime, p::AbstractParticleCollection)\n\nPrints the properties of the particles in the collection.\n\nShould be used internally when overriding Base.show for concrete implementations of AbstractParticleCollection.\n\nThis is not exported.\n\n\n\n\n\n","category":"method"},{"location":"particlecollection/#All-Particles","page":"Particle Collections","title":"All Particles","text":"","category":"section"},{"location":"particlecollection/","page":"Particle Collections","title":"Particle Collections","text":"AllParticles\nparticle_collection\nBase.copy!(dst::AbstractParticles, src::AllParticles, props=())","category":"page"},{"location":"particlecollection/#CosmoParticles.AllParticles","page":"Particle Collections","title":"CosmoParticles.AllParticles","text":"AllParticles{APC} <: AbstractParticles where {APC<:AbstractParticleCollection}\n\nCombines the particles of different types from a particle collection lazily.\n\nThe property arrays of the collection's particles are concatenated lazily with LazyArrays.jl. Scalar properties (e.g. mass for equal-mass particles) are repeated according to the particle number of the given particle type with FillArrays.jl. Properties that only exist for one of the particle types are repeated as missing values in the same way as scalar properties.\n\nUsage\n\nThe individual properties of AllParticles can be converted as regular arrays with Array(ap.pos) and all or selected particle properties can be converted to a Particles object with Particles(ap), where all lazy arrays are materialized as Arrays. AllParticles cannot be sorted, filtered, or copied. In-place modifications are possible, such as rotate!, translate!, or to_comoving.\n\nwarning: In-place modifications\nModifying an AllParticles object in-place results in the modification of the underlying particle collection! To prevent bugs or unexpected behavior, it is advised to modify the particle collection instead and then obtain the object through pc.all or AllParticles(pc) (these are equivalent).\n\nThe lazy concatenation occurs only when the property is needed and is only performed once. Note that this means that calling pc.all.prop multiple times results in the given property being lazily concatenated every time. As long as the property array pointers of the particle collection are not modified (e.g. by sort! or filter!), it is possible to reuse an object ap = pc.all without the need of regenerating the concatenated arrays.\n\nwarning: Modifying the underlying particle collection\nAfter modifying the property array pointers of a particle collection (e.g. by sort! or filter!), any already created AllParticles objects from that collection may have lazy arrays pointing to the old, non-modified arrays. When this happens, create a new object through pc.all or AllParticles(pc).\n\nExample\n\njulia> pc::ParticleCollection\nParticleCollection\ndm: 100 Particles\n id mass pos\ngas: 50 Particles\n id mass pos temp\n\njulia> ap = AllParticles(pc) # equivalent to ap = pc.all\nall: 150 Particles\n id mass pos temp\n\njulia> p = Particles(ap) # p is detached from pc and therefore modifiable\nall: 150 Particles\n id mass pos temp\n\njulia> sort!(p, :id)\n\n\n\n\n\n","category":"type"},{"location":"particlecollection/#CosmoParticles.particle_collection","page":"Particle Collections","title":"CosmoParticles.particle_collection","text":"particle_collection(p::AllParticles)\n\nReturns the underlying particle collection.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particlecollection/#Base.copy!","page":"Particle Collections","title":"Base.copy!","text":"Base.copy!(dst::AbstractParticles, src::AllParticles[, props])\n\nCopies the materialized particle properties to another particle object.\n\nTo only copy certain properties, props can be passed as a tuple of Symbols. The dst cannot be of type AllParticles.\n\n\n\n\n\n","category":"function"},{"location":"particles/","page":"Particles","title":"Particles","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"particles/","page":"Particles","title":"Particles","text":"A set of objects with different properties are represented by subtypes of AbstractParticles. While not absolutely necessary, these kind of objects generally have IDs, positions, and velocity as properties. In the context of cosmological simulations, this applies to particle and galaxy data.","category":"page"},{"location":"particles/","page":"Particles","title":"Particles","text":"For an example implementation of a concrete subtype of AbstractParticles, see the source code of Particles.","category":"page"},{"location":"particles/","page":"Particles","title":"Particles","text":"AbstractParticles\nParticles\nParticles(type)\nParticles(p::AllParticles, props=())\nCosmoParticles.get_props\nCosmoParticles.particle_name\nCosmoParticles.particle_number\nCosmoParticles.show_properties(io::IO, mime::AbstractString, p::AbstractParticles)","category":"page"},{"location":"particles/#CosmoParticles.AbstractParticles","page":"Particles","title":"CosmoParticles.AbstractParticles","text":"abstract type AbstractParticles end\n\nAbstract supertype for storing particle data efficiently in arrays.\n\nParticles generally have IDs, positions, and velocities as properties. The properties are expected to be stored in a Dict{Symbol,Any} as vectors of length N, matrices of size mN, or as scalars (when the property is equal for all particles).\n\nThe inbuilt functionality of AbstractParticles includes accessing and setting properties via the following syntax:\n\np.id = [1, 2, 3]\np[:id] === p.id\n\nIf the struct has additional fields, these can also be accessed by p.field, but not by p[:field]. The latter syntax can only be used to access the particle properties.\n\nProperty keys\n\n:id: vector of IDs\n:pos: 2N or 3N matrix with positions\n:vel: 2N or 3N matrix with velocities\n\nAny arrays may be of the type AbstractArray, provided the arrays are 1-indexed.\n\nMethods\n\nThe methods Base.keys, Base.values, Base.haskey, Base.empty, Base.empty!, Base.isempty, and Base.copy! are forwarded to the property Dict.\n\nConcrete types of AbstractParticles should have the following methods implemented (also see the implementation of Particles):\n\nBase.copy: returns new object containing a copy of the Dict\nBase.empty: returns an identical object, but with an empty Dict\nBase.:(==): should call Base.isequal to prevent obtaining missing results for properties with missing values (relevant for AllParticles)\nCosmoParticles.particle_name: returns the name of the struct to be printed via Base.show\nBase.propertynames: implement this if there are additional struct fields\nBase.show(io, mime, p)\n\n\n\n\n\n","category":"type"},{"location":"particles/#CosmoParticles.Particles","page":"Particles","title":"CosmoParticles.Particles","text":"struct Particles <: AbstractParticles\n    type::Symbol\n    props::Dict{Symbol,Any}\nend\n\nParticles of a certain type (typically something like :dm or :gas in the cosmological context) with their properties.\n\nThe following naming convention is to be used for specific properties:\n\n:id: vector of IDs\n:pos: 2N or 3N matrix with positions\n:vel: 2N or 3N matrix with velocities\n:mass: vector of masses or a scalar if all particles have the same mass\n:temp: vector of temperatures\n\n\n\n\n\n","category":"type"},{"location":"particles/#CosmoParticles.Particles-Tuple{Any}","page":"Particles","title":"CosmoParticles.Particles","text":"Particles(type[, pairs::Pair...])\n\nCreate a Particles object with the given type and pairs of Symbol to the property values. These are passed to the underlying Dict. If no pairs are passed to the method, an empty Dict is created.\n\n\n\n\n\n","category":"method"},{"location":"particles/#CosmoParticles.Particles-2","page":"Particles","title":"CosmoParticles.Particles","text":"Particles(p::AllParticles, props=())\n\nMaterializes the particle properties in a new particle object of type :all.\n\nTo only copy certain properties, props can be passed as a tuple of Symbols.\n\n\n\n\n\n","category":"type"},{"location":"particles/#CosmoParticles.get_props","page":"Particles","title":"CosmoParticles.get_props","text":"CosmoParticles.get_props(p::AbstractParticles)\n\nReturn the property Dict belonging to the particles.\n\nThis returns p.props by default if not overridden.\n\nThis is not exported and should not be used outside of the defining files for particle types.\n\n\n\n\n\n","category":"function"},{"location":"particles/#CosmoParticles.particle_name","page":"Particles","title":"CosmoParticles.particle_name","text":"CosmoParticles.particle_name(p::AbstractParticles)\n\nReturns the name of the particle type, which is used when printing an object of this type via Base.show.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particles/#CosmoParticles.particle_number","page":"Particles","title":"CosmoParticles.particle_number","text":"CosmoParticles.particle_number(p::AbstractParticles)\n\nReturns the number of particles by determining the length of one of the property arrays.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"particles/#CosmoParticles.show_properties-Tuple{IO, AbstractString, AbstractParticles}","page":"Particles","title":"CosmoParticles.show_properties","text":"CosmoParticles.show_properties(io::IO, mime, p::AbstractParticles)\n\nPrints the number of particles, the name of the type, and the property names.\n\nShould be used internally when overriding Base.show for concrete implementations of AbstractParticles.\n\nThis is not exported.\n\n\n\n\n\n","category":"method"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"geometry/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"To filter particles in a particular volume, such as a cube, a sphere, or a cylinder, geometries can be used. This package provides a variety of different geometries for multiple dimensions, including the following:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Hyperrectangle\n3D Rectangular Cuboid\n2D Rectangle\nHypersphere\n3D Sphere\n2D Circle\nCylinder (standing cylinder aligned with the z axis and arbitrary orientation)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"AbstractCosmoGeometry\nCosmoParticles.geometry_enclosing_corners\nCosmoParticles.geometry_enclosing_center\nCosmoParticles.mask_in\nCosmoHyperrectangle\nCosmoCuboid\nCosmoRectangle\nCosmoHypercube\nCosmoCube\nCosmoSquare\nCosmoHypersphere\nCosmoSphere\nCosmoCircle\nCosmoCylinder\nCosmoStandingCylinder","category":"page"},{"location":"geometry/#CosmoParticles.AbstractCosmoGeometry","page":"Geometry","title":"CosmoParticles.AbstractCosmoGeometry","text":"abstract type AbstractCosmoGeometry end\n\nAbstract type for (multi-dimensional) geometry volumes, particularly for filtering with filter.\n\nAny subtypes of AbstractCosmoGeometry have to implement the following methods:\n\nCosmoParticles.geometry_enclosing_corners\nCosmoParticles.geometry_enclosing_center\nCosmoParticles.mask_in\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.geometry_enclosing_corners","page":"Geometry","title":"CosmoParticles.geometry_enclosing_corners","text":"geometry_enclosing_corners(geo::AbstractCosmoGeometry)\n\nReturn the lower left and upper right corners of the enclosing box of the geometry as a tuple of vectors.\n\nThe enclosing box is not necessarily the tightest fitting box.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.geometry_enclosing_center","page":"Geometry","title":"CosmoParticles.geometry_enclosing_center","text":"geometry_enclosing_center(geo::AbstractCosmoGeometry)\n\nReturn the center of the enclosing box of the geometry as a vector.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.mask_in","page":"Geometry","title":"CosmoParticles.mask_in","text":"mask_in(pos::AbstractMatrix{<:Number}, geo::AbstractCosmoGeometry)\n\nReturn the BitArray mask of the positions (mathrmdims times N) located within the geometry.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoHyperrectangle","page":"Geometry","title":"CosmoParticles.CosmoHyperrectangle","text":"struct CosmoHyperrectangle{T,N} <: AbstractCosmoGeometry where {T<:Number}\n    lowerleft::Vector{T}\n    upperright::Vector{T}\nend\n\nHyperrectangle aligned with the coordinate system axes given by its lower left and upper right corners.\n\nThe dimensions of space are given by N.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoCuboid","page":"Geometry","title":"CosmoParticles.CosmoCuboid","text":"CosmoCuboid{T} = CosmoHyperrectangle{T,3}\n\nAlias for a 3D CosmoHyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoRectangle","page":"Geometry","title":"CosmoParticles.CosmoRectangle","text":"CosmoRectangle{T} = CosmoHyperrectangle{T,2}\n\nAlias for a 2D CosmoHyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoHypercube","page":"Geometry","title":"CosmoParticles.CosmoHypercube","text":"CosmoHypercube(center::AbstractVector{<:Number}, radius::Number)\n\nReturn a cubic CosmoCuboid centered around center, with equal sidelengths.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoCube","page":"Geometry","title":"CosmoParticles.CosmoCube","text":"CosmoCube(center::AbstractVector{<:Number}, radius::Number)\n\nReturn a cubic CosmoCuboid centered around center, with equal sidelengths.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoSquare","page":"Geometry","title":"CosmoParticles.CosmoSquare","text":"CosmoSquare(center::AbstractVector{<:Number}, radius::Number)\n\nReturn a square CosmoRectangle centered around center, with equal sidelengths.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#CosmoParticles.CosmoHypersphere","page":"Geometry","title":"CosmoParticles.CosmoHypersphere","text":"struct CosmoHypersphere{T,N} <: AbstractCosmoGeometry where {T<:Number}\n    center::Vector{T}\n    radius::T\nend\n\nHypersphere given by its center and radius.\n\nIf different types are passed to the constructor, the types will be promoted without throwing an error.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoSphere","page":"Geometry","title":"CosmoParticles.CosmoSphere","text":"CosmoSphere{T} = CosmoHypersphere{T,3}\n\nAlias for a 2D CosmoHypersphere.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoCircle","page":"Geometry","title":"CosmoParticles.CosmoCircle","text":"CosmoCircle{T} = CosmoHypersphere{T,2}\n\nAlias for a 2D CosmoHypersphere.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoCylinder","page":"Geometry","title":"CosmoParticles.CosmoCylinder","text":"struct CosmoCylinder{T} <: AbstractCosmoGeometry where {T<:Number}\n    startpos::Vector{T}\n    endpos::Vector{T}\n    radius::T\nend\n\nCylinder given by its end points startpos and endpos and radius.\n\nIf different types are passed to the constructor, the types will be promoted without throwing an error.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#CosmoParticles.CosmoStandingCylinder","page":"Geometry","title":"CosmoParticles.CosmoStandingCylinder","text":"struct CosmoStandingCylinder{T} <: AbstractCosmoGeometry where {T<:Number}\n    center::Vector{T}\n    height::T\n    radius::T\nend\n\nStanding cylinder given by its center, height, and radius.\n\nStanding means that the cylinder is oriented such that its axis is aligned with the z axis. If different types are passed to the constructor, the types will be promoted without throwing an error.\n\n\n\n\n\n","category":"type"},{"location":"properties/","page":"Properties","title":"Properties","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"properties/#Properties","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"properties/","page":"Properties","title":"Properties","text":"colnorm\ncolnorm2","category":"page"},{"location":"properties/#CosmoParticles.colnorm","page":"Properties","title":"CosmoParticles.colnorm","text":"colnorm(a::AbstractMatrix[, origin::AbstractVector])\n\nReturns a new Vector with the columnwise norms of a around origin.\n\nThis method does not check for overflow of the squared norm.\n\n\n\n\n\n","category":"function"},{"location":"properties/#CosmoParticles.colnorm2","page":"Properties","title":"CosmoParticles.colnorm2","text":"colnorm2(a::AbstractMatrix)\n\nReturns a new Vector with the columnwise squared norms of a around origin.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"#CosmoParticles","page":"Home","title":"CosmoParticles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CosmoParticles provides structs and a clean interface for working with sets of particles and galaxies that have individual properties, especially made for dealing with the data extracted from cosmological simulations.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is currently only available via the local registry CosmoSimsRegistry, which can be loaded from the Julia REPL with the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"registry add https://github.com/lucasvalenzuela/CosmoSimsRegistry\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This only needs to be done once per Julia installation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latest version of the package is available for Julia 1.7 and newer versions and can be installed with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"CosmoParticles\")","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/#Transformations","page":"Operations","title":"Transformations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"rotate\nLinearAlgebra.rotate!\ntranslate\ntranslate!\nto_comoving\nto_comoving!\nto_physical\nto_physical!","category":"page"},{"location":"operations/#CosmoParticles.rotate","page":"Operations","title":"CosmoParticles.rotate","text":"rotate(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, prop)\nrotate(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, props=(:pos, :vel))\n\nRotates the specified properties props of the particles p by the rotation matrix rotmat.\n\nCreates a copy of the particles with only new pointers to the rotated properties (by default position and velocity). This means that mutations to other properties will affect both the original particles as well as the rotated copied particles. The properties should be given as a single Symbol, or an array or tuple of Symbols. Only the existing quantities will be rotated (e.g., this method does not throw an error if velocities are not given for the particles).\n\n\n\n\n\nrotate(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, prop)\nrotate(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, props=(:pos, :vel))\n\nRotates the specified properties props of the particles in the collection by the rotation matrix rotmat.\n\nCreates a copy of the particle collection with only new pointers to the rotated particles (by default position and velocity).The properties should be given as a single Symbol, or an array or tuple of Symbols.\n\n\n\n\n\n","category":"function"},{"location":"operations/#LinearAlgebra.rotate!","page":"Operations","title":"LinearAlgebra.rotate!","text":"LinearAlgebra.rotate!(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, props=(:pos, :vel))\nLinearAlgebra.rotate!(p::AbstractParticles, rotmat::AbstractMatrix{<:Real}, prop)\nLinearAlgebra.rotate!(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, props=(:pos, :vel))\nLinearAlgebra.rotate!(pc::AbstractParticleCollection, rotmat::AbstractMatrix{<:Real}, prop)\n\nIn-place version of rotate.\n\nThis function is reexported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate","page":"Operations","title":"CosmoParticles.translate","text":"translate(p::AbstractParticles, Δx, prop::Symbol=:pos)\n\nTranslates the specified property of the particles p by Δx.\n\nCreates a copy of the particles with only new pointers to the translated property. Typically, Δx will be an AbstractVector, e.g., for positions or velocities.\n\n\n\n\n\ntranslate(pc::AbstractParticleCollection, Δx::AbstractVector{<:Number}, prop::Symbol=:pos)\n\nTranslates the specified property of the particles in the collection pc by Δx.\n\nCreates a copy of the particle collection with only new pointers to the translated properties for the particles. Typically, Δx will be an AbstractVector, e.g., for positions or velocities.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.translate!","page":"Operations","title":"CosmoParticles.translate!","text":"translate!(p::AbstractParticles, Δx, prop::Symbol=:pos)\ntranslate!(pc::AbstractParticleCollection, Δx, prop::Symbol=:pos)\n\nIn-place version of translate.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_comoving","page":"Operations","title":"CosmoParticles.to_comoving","text":"to_comoving(p::AbstractParticles, z::Real; propexp=((:pos, 1), (:vel, 1)))\nto_comoving(pc::AbstractParticleCollection; propexp=((:pos, 1), (:vel, 1)))\n\nCreate new particles or collection with particle properties converted from physical to comoving.\n\nThe properties and the positional exponent of their units (e.g., 1 for positions, 3 for volumes, and -3 for densities) are passed as the keyword argument propexp as a tuple of tuples. The redshift z is obtained from redshift for the particle collection.\n\nThe properties are multiplied by (1 + z)^n where n is the positional exponent.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_comoving!","page":"Operations","title":"CosmoParticles.to_comoving!","text":"to_comoving!(p::AbstractParticles, z::Real; propexp=((:pos, 1), (:vel, 1)))\nto_comoving!(pc::AbstractParticleCollection; propexp=((:pos, 1), (:vel, 1)))\n\nConvert particle properties from physical to comoving in-place.\n\nIn-place version of to_comoving.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_physical","page":"Operations","title":"CosmoParticles.to_physical","text":"to_physical(p::AbstractParticles, z::Real; propexp=((:pos, 1), (:vel, 1)))\nto_physical(pc::AbstractParticleCollection; propexp=((:pos, 1), (:vel, 1)))\n\nCreate new particles or collection with particle properties converted from comoving to physical.\n\nThe properties and the positional exponent of their units (e.g., 1 for positions, 3 for volumes, and -3 for densities) are passed as the keyword argument propexp as a tuple of tuples. The redshift z is obtained from redshift for the particle collection.\n\nThe properties are multiplied by (1 + z)^-n where n is the positional exponent.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.to_physical!","page":"Operations","title":"CosmoParticles.to_physical!","text":"to_physical!(p::AbstractParticles, z::Real; propexp=((:pos, 1), (:vel, 1)))\nto_physical!(pc::AbstractParticleCollection; propexp=((:pos, 1), (:vel, 1)))\n\nConvert particle properties from comoving to physical in-place.\n\nIn-place version of to_physical.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Further-Operations","page":"Operations","title":"Further Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Base.sort\nBase.sort!\nBase.filter\nBase.filter!\nCosmoParticles.applyind\nCosmoParticles.applyind!\nCosmoParticles.findall_in\nCosmoParticles.findall_in_sorted","category":"page"},{"location":"operations/#Base.sort","page":"Operations","title":"Base.sort","text":"Base.sort(p::AbstractParticles, prop::Symbol; affect=keys(p), kwargs...)\n\nCreate new particles with the particles sorted according to the specified property.\n\nAll property arrays of the particles are rearranged according to the property being sorted. If the keyword argument affect is a non-empty tuple of Symbols, only those properties are rearranged and added to the newly created particles object. The other keyword arguments are passed on to Base.sortperm.\n\nThe sorting algorithm for unitful properties may also be RadixSort from SortingAlgorithms.jl.\n\n\n\n\n\nBase.sort(pc::AbstractParticleCollection, prop::Symbol; [affect,] kwargs...)\n\nCreate new particle collection with the particles in the collection sorted by calling Base.sort on each of the Particles objects.\n\nIf the keyword argument affect is a non-empty tuple of Symbols, only the affected properties are kept for the particles. The specified affected properties do not have to be available for all particles.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.sort!","page":"Operations","title":"Base.sort!","text":"Base.sort!(p::AbstractParticles, prop::Symbol; kwargs...)\n\nSort the particles in-place according to the specified property.\n\nAll property arrays of the particles are rearranged in-place according to the property being sorted. The keyword arguments are passed on to Base.sortperm.\n\nThe sorting algorithm for unitful properties may also be RadixSort from SortingAlgorithms.jl.\n\n\n\n\n\nBase.sort!(pc::AbstractParticleCollection, prop::Symbol; kwargs...)\n\nSort the particles in the collection in-place by calling Base.sort! on each of the Particles objects.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.filter","page":"Operations","title":"Base.filter","text":"Base.filter(f, p::AbstractParticles; affect=keys(p))\nBase.filter(f, pc::AbstractParticleCollection[; affect])\n\nCreate new particles or collection with the particles filtered by a mask returned by the function f.\n\nThe function f takes the particles as argument and has to either return a BitArray mask with a length of the number of particles or an array of indices. If the keyword argument affect is a non-empty tuple of Symbols, only those properties are filtered and added to the newly created particles object.\n\n\n\n\n\nBase.filter(p::AbstractParticles, ids; affect=keys(p))\nBase.filter(pc::AbstractParticleCollection; ids[, affect])\n\nCreate new particles or collection with them filtered by keeping only the particles with the given IDs.\n\nIf the keyword argument affect is a non-empty tuple of Symbols, only those properties are filtered and added to the newly created particles object.\n\n\n\n\n\nBase.filter(p::AbstractParticles, geo::AbstractCosmoGeometry, prop::Symbol=:pos; affect=keys(p))\nBase.filter(pc::AbstractParticleCollection, geo::AbstractCosmoGeometry, prop::Symbol=:pos[; affect])\n\nCreate new particles or collection with them filtered by keeping only the particles inside the given AbstractCosmoGeometry.\n\nThe filter is applied to the property specified. If the keyword argument affect is a non-empty tuple of Symbols, only those properties are filtered and added to the newly created particles object.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.filter!","page":"Operations","title":"Base.filter!","text":"Base.filter!(f, p::AbstractParticles)\nBase.filter!(f, pc::AbstractParticleCollection)\n\nFilter the particles or collection in-place by masks returned by the function f.\n\nThe function f takes a particles object as argument and has to either return a BitArray mask with a length of the number of particles or an array of indices.\n\n\n\n\n\nBase.filter!(p::AbstractParticles, ids)\nBase.filter!(pc::AbstractParticleCollection; ids)\n\nFilter the particles or collection in-place by keeping only the particles with the given IDs.\n\n\n\n\n\nBase.filter!(p::AbstractParticles, geo::AbstractCosmoGeometry, prop::Symbol=:pos)\nBase.filter!(pc::AbstractParticleCollection, geo::AbstractCosmoGeometry, prop::Symbol=:pos)\n\nFilter the particles or collection in-place by keeping only the particles inside the given AbstractCosmoGeometry.\n\nThe filter is applied to the property specified.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.applyind","page":"Operations","title":"CosmoParticles.applyind","text":"CosmoParticles.applyind(p::AbstractParticles, ind::AbstractVector; affect=keys(p))\n\nCreate new particles with the given indices or mask applied to all particle properties.\n\nThis can also be called by the simple syntax p[ind]. If the keyword argument affect is a non-empty tuple of Symbols, only those properties are indexed into and added to the newly created particles object.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.applyind!","page":"Operations","title":"CosmoParticles.applyind!","text":"CosmoParticles.applyind!(p::AbstractParticles, ind::AbstractVector)\n\nIn-place application of indices or mask to all particle properties.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.findall_in","page":"Operations","title":"CosmoParticles.findall_in","text":"CosmoParticles.findall_in(a::AbstractVector, set)\n\nReturn all indices of a that are in set.\n\nIf both a and set are sorted AbstractVectors, then the optimized findall_in_sorted is called. Otherwise, a Set is constructed from the Vector to perform the checks with in.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.findall_in_sorted","page":"Operations","title":"CosmoParticles.findall_in_sorted","text":"CosmoParticles.findall_in_sorted(a::AbstractVector, set::AbstractVector)\n\nReturn all indices of a that are in set, where both a and set are assumed to be sorted.\n\nThis uses an optimized algorithm that is faster than creating a Set from set and performing checks with in.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Internals","page":"Operations","title":"Internals","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"CosmoParticles.matrix_rotate\nCosmoParticles.matrix_rotate!\nCosmoParticles._applyind","category":"page"},{"location":"operations/#CosmoParticles.matrix_rotate","page":"Operations","title":"CosmoParticles.matrix_rotate","text":"CosmoParticles.matrix_rotate(vals::AbstractMatrix{<:Number}, rotmat::AbstractMatrix{<:Real})\n\nReturns vals rotated by the rotation matrix rotmat by regular matrix multiplication. Works for any dimensions and is optimized for unitful arrays.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles.matrix_rotate!","page":"Operations","title":"CosmoParticles.matrix_rotate!","text":"CosmoParticles.matrix_rotate!(vals::AbstractMatrix{<:Number}, rotmat::AbstractMatrix{<:Real})\n\nIn-place version of CosmoParticles.matrix_rotate.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"operations/#CosmoParticles._applyind","page":"Operations","title":"CosmoParticles._applyind","text":"CosmoParticles._applyind(a, ind::AbstractVector)\n\nApply indices or mask to a Number, Vector, or Matrix.\n\nThe following indexing is applied:\n\na::Number: a is returned directly.\na::Vector: a[ind] is returned.\na::Matrix: a[:, ind] is returned.\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Utils","title":"Utils","text":"CurrentModule = CosmoParticles","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"product_preserve_type\nproduct_preserve_type!","category":"page"},{"location":"utils/#CosmoParticles.product_preserve_type","page":"Utils","title":"CosmoParticles.product_preserve_type","text":"product_preserve_type(arr::AbstractArray{T}, b::Real) where {T}\n\nMultiply an array with a scalar while preserving the element type of the array.\n\nFor unitful arrays, the scalar factor is converted to the number type of the quantity before multiplying.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CosmoParticles.product_preserve_type!","page":"Utils","title":"CosmoParticles.product_preserve_type!","text":"product_preserve_type!(arr::AbstractArray{T}, b::Real) where {T}\n\nMultiply an array with a scalar in-place while preserving the element type of the array.\n\nBy converting the scalar factor to the array element type, this can be more performant than a normal broadcasted product. For unitful arrays, the scalar factor is converted to the number type of the quantity before multiplying.\n\n\n\n\n\n","category":"function"}]
}
